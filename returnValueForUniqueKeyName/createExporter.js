var exporterName="returnValueForUniqueKeyName";
var exporterDescription="returns a value for a unique keyName in the snapshot";
var exporterManager = new CdmExporterManager();

//create exporter
var exporter = exporterManager.createNewExporter(exporterName,exporterDescription);
var exporterId = exporter.getUniqueValue();
​
//create exporter version
var script = " \/**\r\n     @param logger: Logger to log (info, debug, error, warning) messages \r\n     @param primaryDeployable: primary deployable object with the following structure\r\n         {\'app_name\': \'app1\', \'deployable_name\': \'deployable1\', \'snapshot_name\': \'snapshot1\', \'snapshot_id\': \'f707bd813bf7\'}\r\n     @param additionalDeployables: array of additional deployables (in the same order as submitted) with the following structure\r\n     [\r\n         {\'app_name\': \'app1\', \'deployable_name\': \'deployable2\', \'snapshot_name\': \'snapshot1\', \'snapshot_id\': \'f708bddsdsff\'},\r\n         {\'app_name\': \'app1\', \'deployable_name\': \'deployable3\', \'snapshot_name\': \'snapshot1\', \'snapshot_id\': \'f708dfdbddsd\'}\r\n     ]\r\n     @param args: map of arguments where argument name is the key\r\n     @param output: object to store output with the following structure\r\n     output: {\r\n       errors: [],\r\n       warnings: []\r\n       state \'success\' | \'failure\',\r\n       result: \'exported data\'\r\n       disableCaching: false\r\n     }\r\n **\/\r\n (function (logger, primaryDeployable, additionalDeployables, args, output) {\r\n \r\n    var snapshotId = primaryDeployable.snapshot_id;\r\n    gs.info(\"snapshotId is \" + snapshotId );\r\n    \r\n    \/\/check if a proper keyName was provided in the input argument. If not, exit with state error\r\n    if (gs.nil(args.keyName)) { \/\/first check keyName is not null as you cannot check length or trim a null object\r\n        gs.info(\"!!error: empty keyName provided\");\r\n        output.errors = [];\r\n        output.state = \"failure\";\r\n        return output;       \r\n    } else { \/\/next check the length of the trimmed value. If 0 it means only spaces were provided as input\r\n        var filterKeyName = args.keyName.trim(); \/\/trim spaces from input\r\n        if (filterKeyName.length === 0) {         \r\n            gs.info(\"!!error: keyName only contain spaces\");\r\n            output.errors = [];\r\n            output.state = \"failure\";  \r\n            return output;         \r\n        }\r\n    }\u200B\r\n\r\n    \/\/internal variables\r\n    var keyFoundCount = 0; \/\/tracks how often the keyName was found in the snapshot\r\n    \u200B\r\n    \/\/loop through the snapshot datamodel and find the requested keyName\r\n    var cdmQ = new sn_cmdb_ci_class.CdmQuery().snapshotId(snapshotId).followIncludes(true).decryptPassword(true).useCache(true).query();\u200B\r\n    while (node = cdmQ.next()) {\r\n        if (cdmQ.getValue(\"sys_class_name\") == \"sg_cdm_node_cdi\" ) { \/\/only look for CDIs       \r\n            \/\/if the keyName has been found, run the CdmQuery for only that path and store result in output.result \r\n            if (node.getValue(\"name\") === filterKeyName) {\r\n                keyFoundCount++;\r\n                \/\/this exporter expects a unique keyName in the snapshot in order to work correctly. If found more than once, exit with error\r\n                if (keyFoundCount > 1) { \r\n                    gs.info(\"!! error: [\" + filterKeyName + \"]\" + \" was found \" + keyFoundCount + \" times\");\r\n                    output.result={};\r\n                    errorMsg=filterKeyName + \" was found multiple times\";\r\n                    output.errors = {\"error\":errorMsg};\r\n                    output.state = \"failure\";  \r\n                    return output; \r\n                }\r\n                var filterKeyValue= sn_cmdb_ci_class.CdmUtil.getEffectiveValue(node);              \r\n                gs.info(\"filterKeyName \" + cdmQ.getValue(\"name\") + \" found with value \" + filterKeyValue);\r\n                \r\n                output.result = {\"keyValue\":filterKeyValue};\r\n                gs.info(JSON.stringify(output.result));\r\n            }\r\n        }\r\n    }\u200B\r\n\r\n    \/\/in case the keyName was not found set the result to an empty JSON and set the state to failure.\r\n    if (typeof output.result === \'undefined\') {\r\n        output.state=\"failure\";\r\n        output.result = {}; \/\/set empty object for output.result\r\n        errorMsg=filterKeyName + \" was not found in the snapshot\";\r\n        output.errors = {\"error\":errorMsg};\r\n        return output;\r\n    }\u200B\r\n\r\n    \/\/in case the keyName was found once, return a normal response.\r\n\r\n   \/\/output.result = {};\r\n   output.state = \'success\';\r\n   return output;\r\n   \r\n \r\n })(logger, primaryDeployable, additionalDeployables, args, output);";
var exporterVersion = exporterManager.createExporterVersion(exporterId, "info", "description", "", script);
var exporterVersionId = exporterVersion.getUniqueValue();
​
//create exporter argument
var exporterArgument = exporterManager.createExporterArgument(exporterVersionId, "keyName", null, true);

//publish exporter
exporterManager.publishExporterVersion(exporterVersionId);